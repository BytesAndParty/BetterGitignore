/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
If you want to view the source, please visit the GitHub repository.
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BetterGitignorePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/settings.ts
var import_obsidian2 = require("obsidian");

// src/templates.ts
var OBSIDIAN_TEMPLATES = [
  {
    id: "workspaceJson",
    name: "Workspace",
    description: "Current workspace layout",
    pattern: ".obsidian/workspace.json",
    defaultEnabled: true
  },
  {
    id: "workspaceMobileJson",
    name: "Mobile Workspace",
    description: "Mobile workspace layout",
    pattern: ".obsidian/workspace-mobile.json",
    defaultEnabled: true
  },
  {
    id: "trash",
    name: "Trash Folder",
    description: "Obsidian trash folder",
    pattern: ".trash/",
    defaultEnabled: false
  },
  {
    id: "pluginData",
    name: "Plugin Data",
    description: "Plugin settings and cache",
    pattern: ".obsidian/plugins/*/data.json",
    defaultEnabled: false
  },
  {
    id: "hotkeys",
    name: "Hotkeys",
    description: "Custom keyboard shortcuts",
    pattern: ".obsidian/hotkeys.json",
    defaultEnabled: false
  },
  {
    id: "appJson",
    name: "App Settings",
    description: "Application preferences",
    pattern: ".obsidian/app.json",
    defaultEnabled: false
  },
  {
    id: "appearanceJson",
    name: "Appearance",
    description: "Theme and appearance settings",
    pattern: ".obsidian/appearance.json",
    defaultEnabled: false
  },
  {
    id: "graphJson",
    name: "Graph Settings",
    description: "Graph view configuration",
    pattern: ".obsidian/graph.json",
    defaultEnabled: false
  },
  {
    id: "dsStore",
    name: ".DS_Store",
    description: "macOS folder metadata",
    pattern: ".DS_Store",
    defaultEnabled: true
  },
  {
    id: "thumbsDb",
    name: "Thumbs.db",
    description: "Windows thumbnail cache",
    pattern: "Thumbs.db",
    defaultEnabled: true
  }
];
function getDefaultTemplateSettings() {
  const settings = {};
  for (const template of OBSIDIAN_TEMPLATES) {
    settings[template.id] = template.defaultEnabled;
  }
  return settings;
}

// src/gitignoreParser.ts
var MANAGED_SECTION_START = "# === BetterGitignore Managed ===";
var MANAGED_SECTION_END = "# === End BetterGitignore ===";
var GitignoreParser = class {
  constructor(vault) {
    this.vault = vault;
  }
  async exists() {
    return await this.vault.adapter.exists(".gitignore");
  }
  async read() {
    if (await this.exists()) {
      return await this.vault.adapter.read(".gitignore");
    }
    return "";
  }
  async write(content) {
    await this.vault.adapter.write(".gitignore", content);
  }
  parse(content) {
    const startIdx = content.indexOf(MANAGED_SECTION_START);
    const endIdx = content.indexOf(MANAGED_SECTION_END);
    if (startIdx === -1 || endIdx === -1) {
      return {
        beforeManaged: content,
        managedPatterns: [],
        afterManaged: "",
        raw: content
      };
    }
    const beforeManaged = content.substring(0, startIdx).trim();
    const managedSection = content.substring(
      startIdx + MANAGED_SECTION_START.length,
      endIdx
    );
    const afterManaged = content.substring(endIdx + MANAGED_SECTION_END.length).trim();
    const managedPatterns = managedSection.split("\n").map((line) => line.trim()).filter((line) => line && !line.startsWith("#"));
    return {
      beforeManaged,
      managedPatterns,
      afterManaged,
      raw: content
    };
  }
  build(patterns, customContent) {
    const lines = [];
    if (patterns.length > 0) {
      lines.push(MANAGED_SECTION_START);
      lines.push(...patterns);
      lines.push(MANAGED_SECTION_END);
    }
    if (customContent.trim()) {
      if (lines.length > 0) {
        lines.push("");
      }
      lines.push(customContent.trim());
    }
    return lines.join("\n") + "\n";
  }
  async updateManagedPatterns(patterns) {
    const content = await this.read();
    const parsed = this.parse(content);
    let customContent = "";
    if (parsed.beforeManaged) {
      customContent += parsed.beforeManaged;
    }
    if (parsed.afterManaged) {
      if (customContent) {
        customContent += "\n\n";
      }
      customContent += parsed.afterManaged;
    }
    const newContent = this.build(patterns, customContent);
    await this.write(newContent);
  }
  async getCustomContent() {
    const content = await this.read();
    const parsed = this.parse(content);
    let customContent = "";
    if (parsed.beforeManaged) {
      customContent += parsed.beforeManaged;
    }
    if (parsed.afterManaged) {
      if (customContent) {
        customContent += "\n\n";
      }
      customContent += parsed.afterManaged;
    }
    return customContent;
  }
  async setCustomContent(customContent) {
    const content = await this.read();
    const parsed = this.parse(content);
    const newContent = this.build(parsed.managedPatterns, customContent);
    await this.write(newContent);
  }
};

// src/fileScanner.ts
var import_obsidian = require("obsidian");
var FileScanner = class {
  constructor(vault) {
    this.vault = vault;
  }
  async getAllFiles() {
    const files = [];
    const processFolder = async (folder) => {
      for (const child of folder.children) {
        if (child instanceof import_obsidian.TFile) {
          files.push(child.path);
        } else if (child instanceof import_obsidian.TFolder) {
          files.push(child.path + "/");
          await processFolder(child);
        }
      }
    };
    await processFolder(this.vault.getRoot());
    try {
      const hiddenFiles = await this.scanHiddenFiles("");
      files.push(...hiddenFiles);
    } catch (e) {
    }
    return files;
  }
  async scanHiddenFiles(path) {
    const files = [];
    const basePath = path || ".";
    try {
      const items = await this.vault.adapter.list(basePath);
      for (const file of items.files) {
        if (file.startsWith(".") || file.includes("/.")) {
          files.push(file);
        }
      }
      for (const folder of items.folders) {
        if (folder.startsWith(".") || folder.includes("/.")) {
          files.push(folder + "/");
          const subFiles = await this.scanHiddenFiles(folder);
          files.push(...subFiles);
        }
      }
    } catch (e) {
    }
    return files;
  }
  matchesPattern(filePath, pattern) {
    const normalizedPath = filePath.replace(/\\/g, "/");
    const normalizedPattern = pattern.replace(/\\/g, "/");
    if (normalizedPattern.startsWith("!")) {
      return false;
    }
    if (normalizedPattern.endsWith("/")) {
      const dirPattern = normalizedPattern.slice(0, -1);
      return normalizedPath.startsWith(dirPattern + "/") || normalizedPath === dirPattern + "/";
    }
    const regexPattern = this.globToRegex(normalizedPattern);
    return regexPattern.test(normalizedPath);
  }
  globToRegex(pattern) {
    let regex = pattern.replace(/[.+^${}()|[\]\\]/g, "\\$&").replace(/\*\*/g, "{{GLOBSTAR}}").replace(/\*/g, "[^/]*").replace(/\?/g, "[^/]").replace(/{{GLOBSTAR}}/g, ".*");
    if (!pattern.startsWith("/")) {
      regex = "(^|/)" + regex;
    } else {
      regex = "^" + regex.slice(2);
    }
    return new RegExp(regex + "$");
  }
  async getIgnoredFiles(patterns) {
    const allFiles = await this.getAllFiles();
    const ignoredFiles = [];
    for (const file of allFiles) {
      let isIgnored = false;
      for (const pattern of patterns) {
        if (pattern.startsWith("!")) {
          if (this.matchesPattern(file, pattern.slice(1))) {
            isIgnored = false;
          }
        } else if (this.matchesPattern(file, pattern)) {
          isIgnored = true;
        }
      }
      if (isIgnored) {
        ignoredFiles.push(file);
      }
    }
    return ignoredFiles.sort();
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  templates: {},
  customPatterns: ""
};
var BetterGitignoreSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.previewEl = null;
    this.ignoredFilesEl = null;
    this.gitignorePreviewEl = null;
    this.plugin = plugin;
    this.parser = new GitignoreParser(app.vault);
    this.scanner = new FileScanner(app.vault);
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("better-gitignore-settings");
    containerEl.createEl("h1", { text: "Better Gitignore" });
    containerEl.createEl("p", {
      text: "Manage your .gitignore file with quick templates and see which files are being ignored.",
      cls: "setting-item-description"
    });
    this.createTemplatesSection(containerEl);
    await this.createGitignorePreview(containerEl);
    await this.createIgnoredFilesPreview(containerEl);
    this.createAdvancedOptions(containerEl);
  }
  createTemplatesSection(containerEl) {
    const section = containerEl.createDiv({ cls: "templates-section" });
    new import_obsidian2.Setting(section).setName("Quick Templates").setDesc("Toggle common .gitignore patterns for Obsidian").setHeading();
    const grid = section.createDiv({ cls: "templates-grid" });
    for (const template of OBSIDIAN_TEMPLATES) {
      this.createTemplateToggle(grid, template);
    }
  }
  createTemplateToggle(container, template) {
    var _a;
    const item = container.createDiv({ cls: "template-item" });
    const toggle = item.createEl("label", { cls: "template-toggle" });
    const checkbox = toggle.createEl("input", { type: "checkbox" });
    checkbox.checked = (_a = this.plugin.settings.templates[template.id]) != null ? _a : false;
    checkbox.addEventListener("change", async () => {
      this.plugin.settings.templates[template.id] = checkbox.checked;
      await this.plugin.saveSettings();
      await this.updateGitignore();
      await this.refreshPreviews();
    });
    const content = toggle.createDiv({ cls: "template-content" });
    content.createDiv({ cls: "template-name", text: template.name });
    content.createDiv({ cls: "template-pattern", text: template.pattern });
    content.createDiv({
      cls: "template-description",
      text: template.description
    });
  }
  async createGitignorePreview(containerEl) {
    const section = containerEl.createDiv({ cls: "gitignore-preview-section" });
    new import_obsidian2.Setting(section).setName("Current .gitignore").setDesc("Preview of your current .gitignore file").setHeading();
    this.gitignorePreviewEl = section.createDiv({ cls: "gitignore-preview" });
    await this.updateGitignorePreview();
  }
  async updateGitignorePreview() {
    if (!this.gitignorePreviewEl)
      return;
    const content = await this.parser.read();
    if (!content.trim()) {
      this.gitignorePreviewEl.innerHTML = '<span class="empty-state">No .gitignore file yet. Toggle some patterns above to create one.</span>';
      return;
    }
    const highlighted = this.highlightGitignore(content);
    this.gitignorePreviewEl.innerHTML = highlighted;
  }
  highlightGitignore(content) {
    return content.split("\n").map((line) => {
      if (line.startsWith("#")) {
        return `<span class="gitignore-comment">${this.escapeHtml(line)}</span>`;
      } else if (line.startsWith("!")) {
        return `<span class="gitignore-negation">${this.escapeHtml(line)}</span>`;
      } else if (line.trim()) {
        return `<span class="gitignore-pattern">${this.escapeHtml(line)}</span>`;
      }
      return "";
    }).join("\n");
  }
  escapeHtml(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }
  async createIgnoredFilesPreview(containerEl) {
    const section = containerEl.createDiv({ cls: "ignored-files-section" });
    const header = new import_obsidian2.Setting(section).setName("Ignored Files").setDesc("Files currently matched by your .gitignore patterns").setHeading();
    header.addButton(
      (btn) => btn.setButtonText("Refresh").onClick(async () => {
        await this.updateIgnoredFilesPreview();
      })
    );
    this.ignoredFilesEl = section.createDiv({ cls: "ignored-files-list" });
    await this.updateIgnoredFilesPreview();
  }
  async updateIgnoredFilesPreview() {
    if (!this.ignoredFilesEl)
      return;
    this.ignoredFilesEl.empty();
    this.ignoredFilesEl.createDiv({
      cls: "loading",
      text: "Scanning files..."
    });
    try {
      const content = await this.parser.read();
      const patterns = content.split("\n").map((l) => l.trim()).filter((l) => l && !l.startsWith("#"));
      const ignoredFiles = await this.scanner.getIgnoredFiles(patterns);
      this.ignoredFilesEl.empty();
      if (ignoredFiles.length === 0) {
        this.ignoredFilesEl.createDiv({
          cls: "empty-state",
          text: "No files are currently being ignored."
        });
        return;
      }
      const list = this.ignoredFilesEl.createEl("ul", { cls: "files-list" });
      const maxDisplay = 50;
      for (let i = 0; i < Math.min(ignoredFiles.length, maxDisplay); i++) {
        list.createEl("li", { text: ignoredFiles[i] });
      }
      if (ignoredFiles.length > maxDisplay) {
        this.ignoredFilesEl.createDiv({
          cls: "more-files",
          text: `... and ${ignoredFiles.length - maxDisplay} more files`
        });
      }
    } catch (e) {
      this.ignoredFilesEl.empty();
      this.ignoredFilesEl.createDiv({
        cls: "error",
        text: "Error scanning files"
      });
    }
  }
  createAdvancedOptions(containerEl) {
    const section = containerEl.createDiv({ cls: "advanced-section" });
    const details = section.createEl("details");
    const summary = details.createEl("summary", { text: "Advanced Options" });
    summary.addClass("advanced-summary");
    const content = details.createDiv({ cls: "advanced-content" });
    content.createEl("p", {
      text: "Add custom patterns that are not covered by the quick templates.",
      cls: "setting-item-description"
    });
    const textareaContainer = content.createDiv({ cls: "custom-patterns-container" });
    const textarea = new import_obsidian2.TextAreaComponent(textareaContainer);
    textarea.setValue(this.plugin.settings.customPatterns);
    textarea.setPlaceholder(
      "# Custom patterns\n*.log\nnode_modules/\n.env"
    );
    textarea.inputEl.addClass("custom-patterns-textarea");
    textarea.inputEl.rows = 8;
    const saveBtn = content.createEl("button", {
      text: "Save Custom Patterns",
      cls: "mod-cta"
    });
    saveBtn.addEventListener("click", async () => {
      this.plugin.settings.customPatterns = textarea.getValue();
      await this.plugin.saveSettings();
      await this.updateCustomPatterns();
      await this.refreshPreviews();
    });
  }
  async updateGitignore() {
    const patterns = [];
    for (const template of OBSIDIAN_TEMPLATES) {
      if (this.plugin.settings.templates[template.id]) {
        patterns.push(template.pattern);
      }
    }
    await this.parser.updateManagedPatterns(patterns);
  }
  async updateCustomPatterns() {
    await this.parser.setCustomContent(this.plugin.settings.customPatterns);
  }
  async refreshPreviews() {
    await this.updateGitignorePreview();
    await this.updateIgnoredFilesPreview();
  }
};

// src/main.ts
var BetterGitignorePlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new BetterGitignoreSettingTab(this.app, this));
    this.addCommand({
      id: "open-gitignore-settings",
      name: "Open .gitignore editor",
      callback: () => {
        const setting = this.app.setting;
        setting.open();
        setting.openTabById(this.manifest.id);
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    const data = await this.loadData();
    const defaultTemplates = getDefaultTemplateSettings();
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      { templates: defaultTemplates },
      data
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
